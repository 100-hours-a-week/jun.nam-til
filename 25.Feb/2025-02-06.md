## 날짜 : 2025-02-04

### 스크럼
- 학습 목표 1 : 강의 과정에서 배운 동시성, 병렬성 개념 정리
- 학습 목표 2 : 과제 피드백 반영해 수정
- 학습 목표 3 : 모던 JavaScript 튜토리얼 읽으며 JS 내용 정리
- 학습 목표 4 : 알고리즘 공부, 스프링 기초 (시간 있을 시)

### 새로 배운 내용
#### 주제 1: 동시성, 병렬성
- 동시성
  - 하나의 CPU, 동시에 실행되는 것처럼 보이게 (속임수 같은 느낌)
    - Ex. 알바 한명이 여러 테이블에 서비스 제공
  - 주로 싱글 코어에서 멀티스레드를 동작시키기 위한 방식. 여러 스레드가 번갈아가며 실행되는 성질을 뜻함
  - 특징
    - 작업 간 전환
      - 실행되는 작업 간 전환이 이루어지며 실행되는 방식
    - 자원 공유
      - 동일 CPU, 메모리를 공유
    - 운영체제의 역할
      - 스케줄링 알고리즘을 통해 실행되는 작업의 순서를 조정
    - 적용 분야
      - I/O 중심 작업
    - 알아야 하는 이유
      - 서버에서 여러 요청을 적절히, CPU를 쉬지 않게 하며 처리할 수 있기 때문

- 병렬성
  - 여러 작업을 물리적으로 동시에 실행하는 개념 (여러 CPU 코어에서 다른 작업이 수행됨)
    - Ex. 알바 여러 명이, 여러 테이블에 서비스 제공
  - 멀티코어에서 멀티스레드를 동작시키는 방식을 의미. 각 코어에서 한 개 이상의 스레드가 동시에 실행되는 것을 뜻함.
  - 특징
    - 하드웨어 의존적
      - CPU가 여러 개이거나 CPU에서 다중 코어를 지원해야 함
    - 작업의 독립성
      - 각 작업이 물리적으로 독립된 환경에서 실행됨
    - 계산 중심
      - 대규모 데이터 처리, 연산 중심 작업에 최적화
    - 성능 향상
      - 코어 수가 많을수록 더 많은 작업 동시에 처리 가능
    - 알아야 하는 이유
      - 여러 작업을 물리적으로 동시에 처리, 대규모 데이터 처리 성능 극대화를 위해

#### 주제 2: 스케줄러
- 프로세스와 스레드의 실행 순서를 결정
- 특정 작업 완료까지 아무 것도 못하는 상태
- 스케쥴링 알고리즘
    - FCFS (First Come First Serve, = Queue)
        - 비선점 스케줄링 기법
        - 먼저 요청된 순서대로 작업이 처리됨. 그렇기 때문에 작업 시간이 짧은 작업이 긴 작업을 기다리는 경우도 발생
        - 일괄 처리 방식 (Batch Processing)에 적합한 알고리즘
        - 단점
            - Convoy effect
            - 실행시간이 짧은 프로세스들이 실행시간이 긴 프로세스를 계속해서 기다리면서 효율성이 저하됨
    - RR
        - 선점 스케줄링 기법
        - 각 프로세스에 번갈아하며 동일한 시간(time quantum) 동안 CPU를 할당해줌
        - 장점
            - 모든 process가 공평하게 CPU를 할당받음
        - 주의점
            - 너무 길면 FCFS와 다를 게 없음
            - 너무 time quantum을 짧게 설정하면 컨텍스트 스위칭에 의한 오버헤드가 증가함
    - SJF
        - 비선점 스케줄링 기법
        - CPU에 작업 할당 시, 준비되어 있는 작업들 중에서 실행 시간이 제일 짧은 작업을 선택해서 실행시킴.
        - 이미 어떤 작업이 진행 중이라면 새로 들어온 작업의 실행시간이 짧아도 기다려야 함
        - 단점
            - Starvation
            - 실행시간이 긴 프로세스가 영원히 CPU를 할당받을 수 없게됨
    - SRT
        - 선점형 스케줄링 기법
        - 새로운 프로세스가 CPU를 요청할 때마다 스케줄링을 진행함
        - 해당 시점에서 실행시간이 가장 적은 프로세스를 선택해 실행시킴
        - 단점
            - Starvation
                - 실행시간이 긴 프로세스가 영원히 CPU를 할당받을 수 없게됨
            - 실행 시간 측정 문제
                - 매번 스케줄링이 진행됨으로 프로레스가 정확히 언제 실행이 끝날지 쉽게 예측할 수 없다는 문제
    - PQ
        - 비선점, 선점 모두 가능
        - 우선순위가 높은 프로세스가 CPU를 선점
        - 단점
            - Starvation
                - 실행시간이 긴 프로세스가 영원히 CPU를 할당받을 수 없게됨
        - 해결 방안
                - Aging을 통한 우선순위 관리
                    - 대기 시간이 증가함에 따라 우선순위를 높여주는 기법
                    - Multi-Level Feedback Queue를 통해 구현

#### 주제 3: 컨텍스트 스위칭
- 여러 프로세스가 실행되고 있는 환경에서 발생.
- 하나의 프로세스가 실행되는 상태에서 다음 프로세스가 실행되어야 할 떄 발생
- 기존 프로세스를 구성하는 정보 (= context, 프로세스의 현재 상태, PC, 레지스터 값, 프로세스 번호 등)을 저장하고, 새로운 프로세스의 context로 교체하는 작업.
    - 각 프로세스의 정보는 PCB (process control block)에 저장됨
- 다음 프로세스가 실행되어야 하는 상황 = 인터럽트 (interrupt)
    - I/O 요청
    - Time slice expired
    - Fork
    - Interrupt (system call이라던지…)

#### 주제 4: (선택) 암달의 법칙
- 컴퓨터 시스템의 일부를 개선할 때 전체적으로 얼마만큼의 최대 성능 향상이 있는지 계산하는 데 사용
- 프로그램은 병렬처리가 가능한 부분과 불가능한 순차적인 부분으로 구성되므로 프로세서를 아무리 병렬화 시켜도 더 이상 성능이 향상되지 않는 한계가 존재
    - 하드웨어 관점
        - Cache, 메모리, 버스 등을 통해 필요한 데이터를 가져오는 과정 -> 병렬화가 불가능, 오버헤드의 대부분을 차지함

#### 주제 5: (선택) c10k 문제
- “동시 사용자 1만명(Concurrent 10K users)”이 접속하는 서버를 구현하는 문제
- 1만개의 process, 1만개의 thread?
    - 현재의 기술력으로는 잘 돌아감. 하지만 문제가 등장한 시기는 1999년임을 알아야 함
- 자원의 문제
    - 문제 프로세스/스레드 생성에는 고정된 크기의 메모리가 할당됨
    - 문제 1만개의 프로세스/스레드가 CPU를 할당받기 위해 서로 경쟁함 (race condition).

#### 주제 6: 동시성과 병렬성의 차이를 설명해주세요
- 동시성 -> 여러 작업이 수행 가능한 상태로 실행되고 있지만 실제로는 하나만 수행되는 중. 컨텍스트 스위칭을 통해 작업이 번갈아가며 실행됐다 멈췄다함.
- 병렬성 -> 여러 작업이 수행 가능한 상태로 실행되고 여러 개의 스레드가 개별적으로 수행되는 중.
- = 여러 개의 작업에서 동시에 일종의 유의미한 작업이 이뤄지는가에 대한 차이
- 헷갈리는 이유는 두 개념 모두 동시에 어떤 작업을 수행하려는 의도를 가지기 때문.

#### 주제 7: 멀티 쓰레드 환경에서의 동시성과 병렬성을 설명해주세요
- 동시성 : 여러 스레드가 동시에 실행될 수 있음을 의미, 하지만 모든 스레드에서 유의미한 작업이 이뤄지는 것은 아님
- 병렬성 : 여러 스레드가 동시에 실행되고, 각 스레드에서 모두 유의미한 작업이 이뤄질 수 있다는 의미.
- Simultaneously & concurrently
    - 직역하면 둘 다 동시에 라는 의미. 하지만 맥락적으로 보았을 때 담고 있는 의미가 다름.
    - Concurrent : 시작, 실행, 종료가 겹쳐지는 시간에 수행될 수 있는가?
        - 조금 더 구체적으로는 다른 작업의 완료와 관계 없이 새롭게 진행될 수 있는가?
    - Simultaneous : 동일 시간에 실행될 수 있는가?
- 동시성은 병렬성이기 위한 필요조건, 하지만 충분조건은 아님
    - 병렬성 만족 -> 동시성도 만족
    - 동시성 만족 -> 병렬성을 만족하는 것은 아님

#### 주제 8: 컨텍스트 스위칭이 발생할 때 생기는 부정적인 영향에 대해서 설명해주세요
- 컨텍스트 스위칭 오버헤드
    - 컨텍스트 스위칭 발생 시에는 필연적으로 실행 중이던 프로세스/스레드의 정보를 어딘가에 저장하고, 새롭게 실행할 프로세스/스레드의 정보를 가져와서 준비시켜야 하는 시간이 필요
        - = 일종의 예열시간이 필요하다고 할 수 있음
    - 이 시간동안 CPU는 아무런 작업도 하지 못함 -> context switching이 자주 일어나게 되면 오버헤드가 상당하므로 전체 생산성이 떨어질 수 있음
- 조금 더 깊은 관점: 캐시 미스 증가, thrashing
    - 캐시 미스 증가
        - 프로세스/스레드를 실행하며 자주 사용하는 데이터, 명령어 등을 cache에 저장해놓음
        - 컨텍스트 스위칭 발생 시, 캐시 초기화, 메모리 맵핑 초기화도 같이 진행될 수 있음
        - HW적으로 CPU : memory, storage 간 데이터 전송에 걸리는 ovehead가 매우 큼
            - 이 overhead를 줄이기 위해서 cache memory가 존재함
            - Cache에서는 자주 사용될만한 정보들을 저장하다가, CPU 작업 간 요청되는 경우 main memory에 접근하지 않고 cache에 저장되어 있는 정보를 바로 전달함.
    - Thrashing
        - 시스템의 한정된 자원(CPU, 메모리)에 비해 너무 많은 프로세스/스레드가 자원을 할당받으려고 할 때 생기는 문제
        - 실제 유의미한 작업 수행보다 컨텍스트 스위칭에 사용되는 시간이 더 많을 때를 의미함.

#### 주제 9: 스레드 풀을 사용하는 이유와 장단점에 대해서 설명해주세요
- 스레드 풀
    - 고정된 개수의 스레드를 선언해두고 재사용
    - 매번 스레드를 생성, 삭제하는 것은 비용이 꽤 큼
        - 손님이 올 때마다 알바를 고용, 갈 때마다 해고하는 것
    - 스레드 생성, 소멸 시의 오버헤드를 줄임
- 매 요청마다 스레드를 생성하고, 처리가 끝난 스레드를 소멸하는 방식으로 작동한다면?
    - 스레드의 생성, 소멸시에도 상당한 오버헤드가 존재함.
    - 처리 속도보다 더 빠르게 요청이 들어오면 다음과 같은 문제 발생
        - 스레드 계속 생성 → 더 잦은 컨텍스트 스위칭 → 오버헤드 증가
- 장점
    - 고정된 수의 스레드를 사전에 생성해놓고 재활용하는 방식. 생성, 소멸에 의한 오버헤드가 발생하지 않음
        - 매 요청 시마다 스레드를 생성하는 것보다 빠르게 작업을 처리할 수 있음
    - 동시에 실행되는 스레드 수를 제한할 수 있음
        - 작업처리 요청이 갑자기 폭증해도 작업 큐의 작업량만 증가할 뿐 서버 성능은 완만히 저하된다.
- 단점
    - 고정된 수의 스레드를 사전에 생성할 공간을 할당해야 함으로 고정된 메모리 자원을 사용

#### 주제 10: 프로세스 스케쥴링과 스레드 스케쥴링의 차이점에 대해서 설명해주세요
- 컨텍스트 스위칭 과정에서 걸리는 시간의 차이가 존재
- 프로세스의 컨텍스트 스위칭 과정은 크게 지금까지 작업한 내용을 저장 + Flush을 통한 메모리 초기화 작업으로 정리됩니다. 이때, Flush를 하는 이유는 새로 실행되는 프로세스가 기존에 실행되는 프로세스의 메모리 주소 공간에 침범하면 안 되기 때문입니다. 반면, 스레드는 메모리 주소 공간을 공유하기 때문에 Flush 하는 작업을 수행하지 않아도 됩니다. 따라서, 지금까지 작업한 내용을 저장하는 작업만 수행합니다.

### 오늘의 도전 과제와 해결 방법
- 도전 과제 1: 과제 2에서 진행할 간단한 스레드 구현
  - 애니메이션 효과를 구현하는 과정에서 시행착오를 겪었고, 어떠한 부분을 이유로 문제들이 발생했는지 발견할 수 있었음.

### 오늘의 회고
-  SW 레벨 뿐만 아니라 HW 레벨에서의 작동 원리도 알게 된다면 조금 더 깊이 있는, 차별화된 장점을 가질 수 있을 것으로 보임. 
