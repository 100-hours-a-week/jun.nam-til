## 날짜 : 2025-02-1`

### 스크럼
1. 개념 정리
2. 앞서 정리한 내용들 잊지 않게 다시 보기
3. 과제 진행
4. 알고리즘 1문제라도
5. JS 책읽기, 스프링 기초 강의 보기

### 새로 배운 내용
#### 주제 1: 공유 자원이란 무엇이며, 왜 시스템에서 공유 자원을 사용해야 할까요? 실생활 또는 개발 경험에 빗대어 설명해주세요.
- 옛날 환경에 비해 나아지긴 했지만 여전히 시스템에서 가용 가능한 자원에는 상한선이 존재. 
- 각 프로세스, 스레드 등은 생성에 고정된 자원이 필요하고, 사용할 수 있는 자원은 유한하기에 무한대로 생성할 순 없음 (거기다가, 너무 많은 프로세스/스레드가 자원을 먹으면 전체적인 시스템의 성능 저하도 발생할 수 있음)
- 이러한 상황에서, 모든 프로세스/스레드 실행 간 데이터가 독립적은 것은 아님. 몇몇 데이터는 분명 한 번 할당하는 것으로 여러 프로세스/스레드에서 같이 사용될 수 있을 것임. 그러한 유형의 데이터들을 공유 자원으로 선언해 데이터의 중복 선언 및 할당을 막으려는 차원에서 공유 자원이라는 개념이 등장하게 됨.
<br>

#### 주제 2: 임계 영역의 정의와 중요성을 설명하고, 임계 영역을 보호하지 않았을 때 발생할 수 있는 가장 심각한 문제는 무엇이라고 생각하십니까?
- 데이터의 무결성이 보장되지 않는 문제
- 해당 문제가 심각한 이유는 데이터가 잘못된 결과로 저장됨을 의미하고 결국 신뢰성 측면에서 큰 점수를 깎아먹게 됨.
<br>

#### 주제 3: 동기화가 없다면 발생할 수 있는 문제
1. Race condition
    
  - 여러 스레드가 자원에 동시에 접근해 스레드가 실행되는 순서에 따라 결과값이 달라질 수 있다.
  - ex - 은행 계좌 잔고를 갱신하는 과정에서 두 출금 요청이 동시에 들어왔고, 두 출금 요청이 모두 정상적으로 처리됐음에도 잔고에는 하나의 출금 요청에 대한 변화만 반영된 경우
<br>

2. Deadlock
- 스레드 간 자원 점유 순서가 꼬여 무한 대기에 빠질 수 있음
- 한 스레드가 A 자원을 점유한 상태에서 B를 기다리고, 다른 스레드가 B를 점유하며 A를 기다릴 경우 시스템이 멈출 수 있습니다.
<br>

3. Inconsistent data
    
  - 여러 프로세스/스레드가 동시에 공유 데이터를 수정하는 경우, 원래는 실행되지 않아야 하는 상황인데 실행될 수도 있음. 
    
  - ex - 은행 계좌 잔고를 갱신하는 과정에서 두 출금 요청이 동시에 들어왔고, 두 출금 요청의 합이 현재 잔고보다 많음에도 승인되어 잔고가 마이너스로 변한 상황
<br>

#### 주제 4: 락의 기본적인 개념과 동작 방식을 설명해주세요. 락이 데이터 무결성을 어떻게 보장하는지 원자성 개념과 함께 설명해주시면 좋겠습니다.
- 특정 공유 자원을 사용하기 전에 락을 획득해 다른 스레드가 공유 자원에 접근하지 못하도록 방지. 공유 자원의 사용이 끝났다면 락을 반환. 
- 조금 더 나은 비유는 특정 자원의 자물쇠에 대한 열쇠를 스레드가 획득한다고 보면 될 듯.
- 원자성은 특정 작업의 수행이 모두 완료되어 결과에 반영됐거나, 작업의 수행이 전혀 진행되지 않아 결과에 변함이 없어야 만족.
- 락은 특정 작업에 대해 다른 스레드가 간섭하지 못하는 것을 보장하기 때문에 특정 작업의 수행이 원자적으로 이루어지도록 보장.
<br>

#### 주제 5: 뮤텍스와 세마포어의 차이점을 설명하고, 각각 어떤 상황에서 사용하는 것이 적절한지 예시를 들어 설명해주세요.
- 뮤텍스 - 최대 접근 가능 스레드 수: 1개, 프로세스 간 공유 가능
- 세마포어 - 최대 접근 가능 스레드 수 : n개, 프로세스 간 공유 가능
- 뮤텍스의 경우 프로세스 간 공유되는 자원이고, 해당 자원에 한 번에 하나씩만 접근해야 할 필요성이 있을 때 사용
<br>

#### 주제 6: 조건 변수(Condition Variable)는 왜 뮤텍스와 함께 사용해야 할까요? 조건 변수의 역할과 뮤텍스와의 협력 관계를 설명해주세요.
- 조건 변수는 스레드가 특정 조건이 만족될 때까지 대기하고, 다른 스레드가 조건을 만족시킨 후 **신호(Signal)**를 보내 대기 중인 스레드를 깨우는 메커니즘입니다.
- 뮤텍스와 사용해야 하는 이유는 조건 변수 자체에는 별다른 보호 기능이 없기 때문. 조건을 확인하는 동안 context switch 등의 이유로 condition에 변화가 생길 수 있음. 이러한 부분들을 막기 위해 mutex와 조합해서 사용함
<br>

#### 주제 7: 뮤텍스는 데드락 발생 가능성이 있습니다. 데드락의 발생 조건 4가지를 설명하고, 데드락을 예방하기 위한 방법 3가지 이상을 제시해주세요.
- 발생 조건 4가지
  1. Non-preemptive
    - 사용하려는 자원이 선점된 상태라면 뺏어올 수 없음
  2. Circular wait 
    - 사용하려는 자원이 앞서 실행되는 작업에 의해 점유되어 연쇄적으로 기다려야 하는 상태임
  3. Hold & wait
    - 한 번 자원을 선점한다면 수행되기 전까지 자원을 들고 놓지 않음
  4. Mutual Exclusion
    - 각 작업이 동시에 실행될 수 없음

1. 자원에 대한 preemption 진행. 
2. 한 번에 필요한 lock만 획득하는 것이 아닌 작업 수행 간 필요한 모든 lock을 atomically하게 한 번에 획득하도록 함
3. Lock을 획득하는 순서를 정하도록 함
<br>

#### 주제 8: 낙관적 락(Optimistic Lock)은 충돌이 적을 것이라고 가정하고 작동합니다. 만약 충돌이 빈번하게 발생한다면 낙관적 락의 성능은 어떻게 될까요? 낙관적 락의 장점과 단점을 비교 설명해주세요.
- 낙관적 락은 충돌이 적을 것이라 가정하고 작동하기 때문에 충돌이 빈번하게 발생하는 환경에서는 기대 성능에 훨씬 못 미치는 결과를 보여줄 것이라 판단.
- 낙관적 락의 장점은 락이 요구되는 상황이 많이 없고, 있더라고 롤백을 통해 무결성을 보장하겠다는 의도를 가지기에 Lock 때문에 발생하는 실행 간 오버헤드나, 작업의 병렬 처리성이 올라간다는 점이다. 
- 하지만 충돌이 빈번한 환경에선 백을 통해 무결성을 보장하겠다는 의도 때문에 성능 저하가 우려됨. 결국, 롤백을 위해서는 추가적인 구현이나, 롤백을 기다리는 데에 소요하는 시간과 같은 오버헤드가 필연적일 것임. 또한, 롤백 처리 완료 후, 다시 작업을 실행시키는 등 여러 모로 비용 면에서 추가적인 지출이 필요해 보이기도 함.
<br>

#### 주제 9: 데이터베이스 커넥션 풀 또는 스레드 풀을 설계할 때 세마포어(Semaphore)를 어떻게 활용할 수 있을까요? 세마포어의 장점을 활용하여 자원 관리 효율성을 높이는 방안을 설명해주세요.
- 커넥션 풀은 스레드 풀과 마찬가지로 연결 과정에서의 비용이 크기 때문에 일정 수의 connection 을 생성해둔 다음, 재사용하는 것을 목적으로 한다.
- 이러한 과정에서 세마포어 (Semaphore)의 경우 커넥션 풀/스레드 풀을 설계할 때 최대로 실행될 수 있는 커넥션/스레드의 수에 제한을 거는 것으로 자원 관리 효율성에서 이점을 볼 수 있다. 
- 커넥션/스레드 풀에서 사전에 정해둔 수를 넘어가는 연결/생성 요청이 주어지는 경우, 자동으로 대기 상태로 전환되며 자원이 반환되는 순간 signal을 통해 대기 상태로 기다리던 커넥션/스레드가 wake up되어 실행이 재개된다. 
- 해당 방식의 장점은 약간의 context switch 오버헤드는 존재하지만 말 그대로 sleep 상태로 존재하기에 자원을 점유하지 않아 낭비를 방지할 수 있다는 점이다.
<br>

#### 주제 10: JavaScript 프레임워크에서 비동기 작업을 처리하고 상태 관리를 할 때 동시성 문제를 어떻게 고려해야 할까요?
- 자바스크립트는 기본적으로 싱글 스레드 기반이지만 Event-loop, async와 같이 비동기적으로 프로그램이 실행될 수 있기도 함.
- 이러한 상황에서 async-await를 통한 비동기 처리의 올바른 수행 결과 보장, 뮤텍스와 같은 동시성을 보장할 수 있는 개념을 도입하거나 상태 관리 라이브러리 등을 활용해서 동시성과 관련된 문제들의 발생 빈도를 낮출 수 있을 거 같다.
<br>

### 오늘의 도전 과제와 해결 방법
- 오늘은 딱히 새롭게 진행한 것이 없었다.

### 오늘의 회고
-  오늘은 특강도 진행하고 새롭게 배운 내용이 없었기에 어제 진행했던 개념 정리에서 미처 마치지 못한 질문들에 대한 정리를 진행했다.
