## 날짜 : 2025-02-04

### 스크럼
1. 딥다이브 내용 정리
2. 앞서 정리한 내용들 잊지 않게 다시 보기
3. 과제 진행
4. 알고리즘 1문제라도
5. JS 책읽기, 스프링 기초 강의 보기

### 새로 배운 내용
#### 주제 1: 추상클래스와 인터페이스
- 추상 클래스와 인터페이스는 자바 객체 지향 설계에서 추상화와 다형성을 구현하는 핵심 요소
- 둘의 차이를 먼저 보자면
  - 일반 클래스는 객체를 생성할 수 있는 일반적인 클래스,
  - 추상 클래스는 추상 메서드를 가질 수 있으며 직접 객체 생성 불가,
  - 인터페이스는 모든 메서드가 기본적으로 추상이며 구현을 강제한다.

- 추상 클래스
  - 일부 메서드에 대해 구현을 제공하지 않고, 자식 클래스에서 이를 구현하도록 강제하는 클래스. 

  - `abstract` 예약어 사용을 통해 추상 클래스를 선언할 수 있다.
  - 메소드도 `abstract` 예약어 사용을 통해 추상 메소드로 선언할 수 있음.
      - 추상 메소드는 선언만 하고 구현은 하지 않음
      - 추상 클래스/인터페이스에서만 선언 가능
  - 상속을 통해 재사용성 제공
  - 추상 클래스로는 객체를 생성할 수 없다.
  - 언제 사용하는지, 또 왜 사용하는지
    - 공통 기능을 제공하면서 일부를 강제하기 위해 사용
        - 반복적인 코드 작성을 줄이고, 대부분의 기본적인 동작을 정의하되 필요한 부분만 자식 클래스에서 사용할 방식으로 구현하도록
    - 추상 클래스에 꼭 추상 메소드가 있어야 하는 것은 아님
        - 그럼에도 추상 클래스도 선언하는 이유는?
            - 직접 객체를 만들지 못하도록 제한하기 위해
            - 설계상 ‘직접 사용하면 안 되는 클래스’를 만들고 싶을 때, 상속을 강제하고 싶을 때 반드시 상속해서 사용해라 라는 의도 전달 가능
        - 특정 메소드를 오버라이딩하지 못하게 보호할 수 있다


- 인터페이스
  - 추상 메서드와 상수를 포함하며, 클래스가 구현해야 할 기능을 정의

  - 다형성 지원, 클래스들이 공통적으로 따라야 할 규약 정의
  - 다중 상속 가능 : 여러 인터페이스를 하나의 클래스에서 구현할 수 있다
      - **다중 상속**: 하나의 클래스가 여러 개의 상위 클래스를 상속 받는 것.
      - 다이아몬드 문제
  - 인터페이스는 기본적으로 추상 메서드임.
      - 객체화 불가 → 인스턴스를 생성할 수 없음
  - 인터페이스를 사용하는 클래스는 반드시 **메서드 구현**을 해야 한다.
  
  인터페이스는 왜 추상 메서드만 가지도록 제한되어 있을까? 
  
  - 모든 클래스가 ‘반드시 구현해야 하는 메서드’를 강제하기 위해 존재
  - 일관된 설계를 보장할 수 있다

#### 주제 2: Java 직렬화와 역직렬화
- 직렬화란?
  - 자바에서의 Object, Data 등을 다른 컴퓨터의 자바 시스템에서도 이용 가능하도록 바이트 스트림 (Stream of Bytes) 형태로 연속적인 데이터로 변환하는 변환 기술
- 역직렬화란?
  - 직렬화된 데이터를 다시 원래의 형태로 만드는 것
- 바이트 스트림 이란?
  - 스트림은 클라이언트나 서버 간에 출발지 목적지로 입출력하기 위한 데이터가 흐르는 통로를 말한다.
  - 자바는 스트림의 기본 단위를 바이트로 두고 있기 때문에, 네트워크, 데이터베이스로 전송하기 위해 최소 단위인 바이트 스트림으로 변환하여 처리한다
- 사용 시점과 활용 사례
  - 네트워크를 통해 클라이언트 간 데이터를 주고 받을 때 사용
  - 자바 RMI (Remote Method Invocation): 원격 시스템간의 메세지 교환에 사용되는 자바 기술. 객체 데이터를 직렬화하여 메세지에 포함 시킨다.
  - 서블릿 세션(Servlet Session) : 세션 데이터를 저장&공유
  - 캐시 (Cache) - 캐시에 데이터베이스에서 조회해온 데이터의 객체가 있다. 이 데이터를 다른 모듈에서 필요할 때, 데이터베이스를 다시 조회하는 것이 아니라 객체를 직렬화하여 메모리에 저장해두고 필요할 때 다시 역직렬화 하여 사용

#### 주제 3: NULL 처리
- Null의 정확한 의미 
  - Null의 특성을 알아보면 int, char와 같은 원시 자료형에는 null을 대입할 수 없는 것을 알 수 있음
  - 왜 그런걸까?
    - 원시 자료형의 경우 0, 빈 문자열, false 등 값이 없을 때의 상태를 간접적으로 표현할 수 있기 때문
    - 구체적으로 말한다면 자료형 중 참조 자료형인 경우에 빈 값을 의미하기 위해 Null을 사용할 수 있음 .
    - C에서는 메모리의 주소를 ‘포인터’를 통해 가리킬 수 있음. 즉 포인터 = 메모리의 특정 주소를 저장하는 변수 타입이라는 것.
    - int나 char 같은 데이터 타입을 초기값으로 초기화할 때는 0, ‘’와 같은 값으로 초기화를 진행함. 
  - 포인터 변수는 어떤 초기값으로 초기화를 진행하게 되는 걸까?
    - 원시 자료형과 마찬가지로 0이나 ‘’같은 아무 것도 없는 상태의 주소값을 표현해야 하는데 이 때 사용하는 키워드가 Null이다. 즉, NULL은 주소값이 없는 것 (포인터가 어떤 메모리 주소도 가리키지 않는 것)을 말하는 것.
- 자바에서의 포인터?
  - 자바에서는 포인터를 다룰 일도 없고, 포인터가 없다라고 배웠을 수도 있음. 
    - 엄연히 말한다면 자바에서의 포인터 개념은 없앤 것이 아닌 편의성을 위해 숨긴 것에 가까움. 
    - 자바의 배열, 객체, 스트링과 같은 reference 타입이 모두 포인터 변수라고 볼 수 있음.
  - 자바의 참조 변수와 포인터의 공통점
    - 메모리에 직접 접근
    - 차이점
      - 자바의 참조 변수는 메모리 주소값을 변경할 수 없다
- NullPointerException
  - 런타임에 발생하는 오류
    1. null을 참조하는 객체의 메소드를 호출하는 경우
    2. 원시 타입에 null을 할당하는 경우
    3. 관계 연산자에 null 사용하는 경우
        1. ==, ≠ 기호는 사용 가능
- null 사용시 주의점
  1. **API에 null을 최대한 쓰지 말아라**
      - 명시적인 메소드를 만든다.
          - null로 분기 처리하는 대신 다형성을 사용한다.
      - null을 반환하지 않는다.
          - 반환값 필요시 예외 처리
          - 빈 반환값: 빈 컬렉션, Null 객체, Optional 활용
  2. **계약에 의한 설계: 사전 조건과 사후 조건을 확인하라**
      - 개방-폐쇄 원칙의 상위 개념
      - null이 들어오지 말아야 한다면 잘 확인해야 한다.
  3. **null 범위를 지역(클래스, 메소드)에 제한하라**
      - 클래스와 메소드를 작게 만든다.
  4. **초기화를 명확히 하라**
      - 실행 시점에 초기화되지 않은 필드가 없어야 한다.
      - 객체 필드의 생명주기 == 객체의 생명주기

#### 주제 4: 스레드를 사용했을 때 장단점을 서술하고 스레드의 생명주기에 대해 서술하시오. 
- 스레드란? 
  - 프로세스 내부에서 실행되는 작은 작업 단위
  - 프로세스는 독립된 객체로서 생성되면 각각의 메모리 자원을 할당 받고, 서로에게 접근이 불가능하다. 프로세스 특성상 서로에게 접근이 불가능하기에, 여러개의 프로세스를 처리하기 위해서 서로의 상태 자원을 공유하려면 IPC라는 커뮤니케이션 기법이 필요하다. IPC는 커널의 공유 메모리를 활용하여 프로세스들간의 데이터 상태 정보를 주고 받는다.
  - 특징
    1. 프로세스들이 서로의 데이터에 불가능한 반면, 스레드들끼리는 서로의 데이터에 접근 가능
        1. IPC 등과 같은 통신을 이유로 하는 오버헤드가 발생하지 않음
    2. 작업을 병렬로 처리해서 속도를 높일 수 있음
    3. 메모리 영역을 크게 4가지(code, data, stack, heap)으로 나눴을 때, code - data - heap 영역은 공유하기 때문에 생성에 있어 프로세스보다 자원 소모가 덜하다.
- 장단점
  - 장점
    - 다중 프로세스를 할 때보다 다중 스레드를 활용하는 것이 `오버헤드`를 더 줄일 수 있다.
      - 프로세스에 비해 컨텍스트 스위칭 발생 시 바뀌어야 하는 내용들이 적기 때문
    - 동시성 혹은 병렬성을 만족하는 실행 흐름을 구현할 수 있다.
  - 단점
    - 스레드 수가 많으면 스레드 간 전환에 따른 부담이 증가한다. (컨텐스트 스위칭 비용)
    - 스레드마다 각자 독립적인 스택 영역이 필요한데, 많은 수의 스레드를 생성하면 메모리와 기타 시스템 리소스를 너무 많이 소비하게 된다.
    - 여러 스레드가 동일한 자원에 동시에 접근하려할 때 데이터의 일관성이 깨질 수 있다.
- 생명주기
 - 스레드의 생성과 소멸까지의 시간에 대한 범위 혹은 시점을 나타냄
    - New (새로운 상태)	: 스레드가 생성되었으나 아직 시작되지 않은 상태.
    - Runnable (실행 가능 : 상태)	스레드가 실행 중이거나 실행될 준비가 된 상태.
    - Blocked (차단 상태)	: 스레드가 동기화 락을 기다리는 상태
    - Waiting (대기 상태)	: 스레드가 무기한으로 다른 스레드의 작업을 기다리는 상태
    - Timed Waiting (시간 제한 대기 상태)	: 스레드가 일정 시간 동안 다른 스레드의 작업을 기다리는 상태
    - Terminated (종료 상태) :	스레드의 실행이 완료된 상태
- 데드락은 왜 발생하게 되는 걸까?
  1. 프로그램을 구성하는 구성 요소 간 의존성이 생기기 때문.
  2. 캡슐화의 문제
      1. 구현 간, 편의성을 위해서 내부에서 어떻게 구현되는지에 대한 내용을 숨길 것을 권장받음. 
      2. 어떻게 구현되었는지 모르는 상태이기 때문에 특정 로직을 적용했을 때 데드락이 생길지, 생기지 않을지 확신할 수가 없음
- 스레드풀 (Thread Pool)
  - 개념과 특징
    - 고정된 수의 스레드를 사전에 생성해놓고 필요 시 스레드 풀에서 스레드를 꺼내와서 재사용
    - 스레드를 미리 생성해두기 때문에 생성과 종료가 빈번하게 일어나지 않는다.
    - 자료구조의 대기열(큐)을 이용하여 작업을 스레드에게 전달한다.
    - 작업을 전달하는 것은 생산자이며, 작업을 처리하는 스레드는 소비자이다. 고전적인 생산자-소비자 패턴을 띄고 있다.
  
#### 주제 5: 스레드 안전성
- 스레드 안전 (Thread safety)이란?
  - 두 개 이상의 스레드가 특정 변수, 함수, 객체을 요구하는 경쟁 상태 (race condition)에 놓였을 때, 모든 연산 수행 후 기대값과 비교했을 때 결과에 모순이 발생하지 않음을 의미.
- 스레드 안전의 여부 판단 방법
  - 자원의 생성, 사용, 소멸이 동일한 스레드 내에서 이루어지고, 해당 스레드에서만 사용한다면 thread-safe하다. 
- 보장 방법
  1. Mutual Exclusion (상호 배제)
    - 특정 시점의 임계 영역에서 두 개 이상의 프로세스가 같이 존재할 수 없다 - Dijkstra
    - 공유 자원에 대해 Lock, Semaphore, Mutex의 활용을 통해 하나의 스레드만 접근할 수 있도록 통제하는 방식.
    - Lock, Semaphore, Mutex에는 어떤 차이점이 있나요? 
      - Lock - 프로세스 간 공유 불가, 동시 접근 가능 스레드 1개
      - Mutex - 프로세스 간 공유 가능, 동시 접근 가능 스레드 1개
      - Semaphore - 프로세스 간 공유 불가, 동시 접근 가능 스레드 여러 개
  2. Atomic Operation (원자 연산)
    - 공유 자원에 접근할 때는 원자 연산을 이용하거나, 원자적으로 정의된 접근 방법을 사용함으로 상호 배제를 구현 가능
  3. Thread-Local-Storage (스레드 지역 저장소)
    - 전역 변수 사용을 자제하라는 뜻으로 생각하면 된다.
  4. Re-entrancy (재진입성)
    - 정의: 여러 스레드에 의해 호출 되었을 때, 공유 자원에 접근하지 않는다면 해당 함수를 re-entrant하다고 부름.
      - - 지역 (non-static) 변수만 사용
      - 별다른 동기화 작업 없이 실행 했을 때 문제가 없어야 함
          - 호출하려는 함수의 작동이 끝나지 않은 상황이라 가정
          - 해당 함수를 다시 호출하더라도 교착 상태와 같이 프로그램 실행 흐름에 영향 받지 않아야 함
      - Thread-safe ≠ Re-entrant
        - 왜 thread-safe는 re-entrant와 동의어가 아닌가요?
          - https://www.notion.so/25-02-07-193b7198b664808ca5c6f02b9b4e5b70?pvs=4#193b7198b6648058a646e644a0638a6d 
- Javascript and Thread Safe
  - 그렇다면 자바스크립트 v8 엔진은 thread safe 할까?
  - 답은 그렇다이다. 싱글 스레드로 돌아가기 때문에 동시에 여러 스레드가 하나의 함수나 변수에 접근할 일이 없다.
- C and Thread Safe
  - C에서 구현되어 있는 대부분의 함수들은 thread-safe하게 구현되어 있음. 
  - 물론 몇몇 예외 함수가 존재 (ex. rand() 함수)하긴 하지만 이러한 함수들도 thread-safe하게 구현된, 대안으로 사용할 함수들이 정의된 라이브러리가 존재함.

#### 주제 6: synchronized vs volatile
- 가시성 문제
  - volatile 선언을 통해 해결 가능
- 원자성 보장
  - syncrhonized 키워드를 통해 구현
- 사용 시 유의할 점
  - synchronized
    - 사용 시 block상태로 전환시키기 때문에 필요한 부분에서만, 최대한 작은 영역에 대해 synchronized를 사용할 수 있도록 할 것.
  - volatile
    - 원자성을 보장하지 않음. 별개의 동기화 기법 적용이 필요할 수 있음.
- volatile과 최적화(optimization) 간의 관계
  - 요즘에는 컴파일러 성능이 워낙 좋아서 컴파일을 진행하면서 조금 더 프로그램 성능, 수행 시간 면에서 이점을 볼 수 있도록 자동적인 코드 리팩토링을 진행함 (assembly 코드 레벨에서의)
  - 하지만, 모든 상황에서 최적화가 옳은 선택인 것은 아님.  최적화가 적용되지 않은, 비효율적인 코드가 순차적으로 실행되어야 하는 상황들도 있기 때문.
  - 이걸 알기 위해서는 volatile이 주로 사용되는 사용처를 알면 좋음 
    - 인터럽트 서비스 루틴
    - 메모리 맵 입출력
    - 신호 처리
  - 딱 봐도 자주 접할만한 단어들은 아니라고 생각. 간단하게 설명해보자면 다음과 같음.
    - 인터럽트 서비스 루틴
      - 하드웨어 인터럽트 발생 시 이렇게 처리해주세요 라고 사전에 정의해 놓은 실행할 내용
        - 하드웨어 인터럽트 = 키보드 입력, 마우스 입력 등등
    - 메모리 맵 입출력
      - 특정 메모리 주소를 통해 하드웨어 장치와 통신할 때 사용
      - CPU와 주변 기기 (마우스, 키보드 등) 간  I/O 발생 시 변경된 부분을 갱신하기 위해 메모리 맵 입출력을 통해 변경점 탐색
    - 신호 처리
      - OS에서 사용되는 시스템 콜 등을 처리하기 위한 신호 처리기(signal handler)와 메인 프로그램 간 사용되는 변수.
  - write -> var1 = 10, -> var2 = var1 -> read 의 순서대로 실행되는 코드가 있다고 가정
    - 그냥 봤을 때 뭔가 비효율적인 코드 같지 않나요?
      - 최적화 진행을 하게 된다면 var2 = 10으로 바로 선언할 수 있을 것.
  - write와 read 사이에 var1의 값이 계속 변경되는 프로그램이라면 해당 최적화가 어떻게 생각되나요?
    - 실행되는 프로그램이 타이머라고 가정.
    - 타이머의 화면에 시간을 초 단위로 표현해야 하는데, 시간이 지나도 계속 똑같은 숫자만 출력 될 수도 있음을 의미.
    - 이러한 상황들에서는 하드웨어와의 직접적인 상호작용이 필요하기 때문에, 컴파일러의 최적화로 인한 메모리 접근 순서 변경이나 캐시 사용이 오히려 문제를 일으킬 수 있습니다. volatile 키워드는 이러한 최적화를 방지하고 항상 메모리에서 직접 값을 읽고 쓰도록 보장합니다.


### 오늘의 도전 과제와 해결 방법
- 도전 과제 1: 과제 2에서 진행할 간단한 스레드 구현
  - 애니메이션 효과를 구현하는 과정에서 시행착오를 겪었고, 어떠한 부분을 이유로 문제들이 발생했는지 발견할 수 있었음.

### 오늘의 회고
-  딥다이브 진행 과정이 너무 힘들었다. 그래도 힘든 만큼 얻어 가는 것도 많다고 생각.
