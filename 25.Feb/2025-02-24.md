## 날짜 : 2025-02-24

### 스크럼
1. 개념 정리
2. 앞서 정리한 내용들 잊지 않게 다시 보기
3. 과제 진행
4. 알고리즘 1문제라도
5. JS 책읽기, CSS 공부

### 새로 배운 내용
#### 주제 1: 실행 컨텍스트
- 함수가 호출될 때 생성되는 배경 정보 및 변수, 스코프 정보
    - 코드 실행에 필요한 환경 정보를 모아둔 객체
    - 실행될 때마다 JS의 call stack에 실행된 순서대로 컨텍스트를 쌓음.
    - `전역`, `함수` 실행 컨텍스트로 나뉨

- 알아야 하는 이유

    - 엔진이 어떻게 코드를 해석하는지에 대한 이해를 통해 코드 실행 간 문제가 없도록 하기 위해

- 전역/함수 실행 컨텍스트
    - 전역
        - 전역 객체, 변수에 대한 정보와 전역 스코프 체인 구성에 대한 내용을 모아둔 실행 컨텍스트
    - 함수
        - 함수가 호출될 때마다 생성되는 실행 컨텍스트
        - 매개변수, 지역 변수, arguments 객체, 렉시컬 스코프 체인에 대한 내용을 모아둔 실행 컨텍스트

- `콜 스택 (Call Stack)` 과정
    - 실행 컨텍스트를 관리하는 스택 구조
    - 함수 호출 시 새로운 실행 컨텍스트가 스택에 push.
    - 함수 종료 시 pop되며 `LIFO`방식으로 순서를 관리

- `스코프 체인`
    - 함수나 코드 블록이 변수, 함수 등이 정의된 부분을 식별하기 위해 참조하는 렉시컬 환경의 연결고리
    - `렉시컬 환경`
        - 현재 실행 컨텍스트에 선언된 변수와 상위 스코프의 참조 정보를 포함
        - 현재 스코프 → 외부 스코프 → … → 전역 스코프 순으로 탐색

- Variable Env.(변수 환경)
    - 현재 실행 컨텍스트에서 선언된 변수와 함수에 대한 정보를 담고 있는 환경
    - 최초 실행 컨텍스트 생성 시점의 스냅샷을 유지하는 특징

- Lexical Env(렉시컬 환경)
    - 코드가 작성된 위치(렉시컬 스코프)에 따라 결정되는 식별자(변수, 함수 등)의 바인딩 정보를 관리하는 내부 구조
    - 변수 환경과 비슷하게 변수, 함수에 대한 정보를 가지지만 실행단계에서 동적으로 변한다.
    - Environment Record(환경 레코드)
        - 실제 변수, 함수, 매개변수 등 식별자와 그 값(또는 참조)을 key-value형태로 저장하는 객체
        - 함수나 코드 블록 내에서 선언된 모든 식별자가 이 레코드에 기록됨
    - Outer Environment Reference
        - 현재재 렉시컬 환경의 상위 환경(부모 스코프)을 가리키는 참조 링크
        - 현재 환경에 해당 식별자가 없을 경우, 상위 스코프에서 식별자를 검색하는 스코프 체인이 형성됨

- `호이스팅`
    - 변수 및 함수 선언이 해당 스코프의 최상단으로 끌어올려지는 현상 (실제 물리적 코드에 변화가 발생하는 것은   아님)
    - 초기화는 실제 코드 위치에서 진행
    - `var`, `const`, `let`
        - 이 세 예약어는 변수 선언을 위해 사용되지만 scope에서 차이를 보임
            - `var`
                - function 단위의 scope
                - 호이스팅 시 `undefined`로 초기화 진행.
            - `const`, `let`
                - {} (block) 단위의 scope
                - 호이스팅 시 `undefined`로 초기화가 진행되지 않음.
                    - 호이스팅은 가능하지만 실제 값의 할당은 선언 시점 부분에서 이루어짐
    - `TDZ` (Temporal Dead Zone)
        - 변수 선언 ~ 초기화 사이 구간을 TDZ라고 부름
        - TDZ에 있는 변수 접근 시 `Reference Error` 발생
<br>

#### 주제 2: Scope
- 변수에 접근할 수 있는 범위

- 전역 스코프
    - 코드의 모든 영역에서 접근 가능

- 함수 스코프
    - `var` 변수는 함수 내부에서만 유효
    - 외부에서 해당 변수에 접근 불가, local 상태를 유지하는 데 유리
    - 실행 컨텍스트가 생성될 때 함께 만들어지며, 함수 종료 시 소멸합니다.

- 블록 스코프
    - `let`, `const`는 함수 내부에서만 유효
    - `var`보다 엄격하게 범위를 제한, 코드 복잡성을 줄이고 오류 가능성을 낮춤

- 사용 이유
    - 변수 충돌 방지
        - 서로 다른 scope에서 동일 이름의 변수를 독립적 사용 가능
    - 메모리 효율성
        - scope를 통해 변수의 생명주기 관리
        - 필요하지 않은 변수가 메모리 차지하는 것 방지
    - 보안 및 캡슐화
        - Scope를 사용해 중요 데이터를 외부 접근에서 보호
        - 내부 구현을 숨겨 안정성 강화
    - 가독성 유지 및 관리성 향상
        - Scope를 명확하게 사용함으로 코드의 흐름과 로직이 분명하게 나뉨
        - 디버깅과 유지보수에 있어 장점
    - 모듈성 증진
        - 코드의 모듈화
        - 각 부분이 독립적으로 기능하도록 함 → 재사용성, 확장성 향상
<br>

#### 주제 3: this
- 실행 컨텍스트를 참조하는, 자동으로 할당이 진행되는 지역 변수

- 바인딩 결정 방식
    - `기본 바인딩`
        - 일반 함수 호출 시 적용
        - Non-strict mode
            - this는 전역 객체를 가리킴
        - Strict mode
            - 기본 바인딩이 undefined로 설정됨. 이는 의도치 않은 전역 객체 참조를 방지하기 위함
    - `암시적 바인딩`
        - 객체의 메소드로 함수를 호출할 때 적용
        - 함수 호출 시점에 해당 객체의 프로퍼티로 등록되어 있으면, 그 객체가 this로 바인딩됨
    
    ```jsx
    const obj = {
      name: 'Alice',
      greet() {
        console.log(this.name);
      }
    };
    
    obj.greet(); // 출력: 'Alice' → 암시적으로 obj가 this로 결정됨
    ```
    
    - `명시적 바인딩`
        - call, apply, bind 메소드를 통해 함수 호출 시 this를 명시적으로 지정 가능
        - call
            - 인수를 쉼표로 구분해 전달, 함수 즉시 호출
        - apply
            - 인수를 배열로 전달, 함수 즉시 호출
        - bind
            - this와 초기 인수를 고정한 새로운 함수를 반환하여, 나중에 호출할 수 있음
    - `new 바인딩`
        - 생성자를 new와 사용할 때 적용
        - new 연산자는 내부적으로 새로운 빈 객체를 생성한 후, 그 객체를 this로 바인딩하여 함수를 실행
        - 생성자 함수 내부에서 this는 생성된 인스턴스를 가리키며, 해당 인스턴스에 프로퍼티나 메소드를 할당할 수     있음
    - `화살표 함수 바인딩`
        - 정의된 렉시컬 환경의 this를 그대로 사용
        - 화살표 함수 내에서 this를 참조하면 상위 스코프(부모 함수 또는 전역 스코프)의 this를 그대로 가져옴
        - 콜백 함수나 이벤트 핸들러 등에서 주로 사용

- 일반 함수, 화살표 함수의 this 차이
    - 일반 함수
        - 호출 방식에 따라 this가 동적으로 결정됨
        - 메소드로 사용하거나 생성자로 사용 시 각각 다른 this 바인딩을 가짐
    - 화살표 함수
        - 자신만의 this를 갖지 않고, 정의된 렉시컬 환경(상위 스코프)의 this를 그대로 사용
        - 주로 콜백 함수나 간결한 표현이 필요할 때 유용하지만, 생성자 함수로는 사용할 수 없음

<br>

#### 주제 4: JS Prototype
- 객체가 새로 생성될 때, 기본적으로 갖게 되는 상속 받을 수 있는 속성, 메소드의 집합
    - 생성과 동시에 prototype과 연결됨
    - 모든 함수는 `prototype` 속성을 가지며, 이 객체를 통해 인스턴스들이 공통된 속성과 메소드를 공유

- 프로토타입 체인
    - 속성을 찾을 때, 해당 객체에 없으면 **프로토타입 체인**을 따라 상위 프로토타입(예: Object.prototype)까지   탐색
    - 공통 기능의 재사용이 가능

- 클래스와 prototype의 차이
    - **문법적 차이**:
        - class 문법은 생성자, 메소드, 상속을 보다 명료하게 정의할 수 있도록 돕습니다.
    - **구현 방식**:
        - class를 사용해 작성된 코드는 내부적으로 프로토타입 체인을 활용하지만, 개발자는 이를 직접 다루지 않아도    됩니다.
    - **가독성 및 유지보수**:
        - class 문법은 객체 지향 프로그래밍(OOP)을 선호하는 개발자들에게 보다 친숙하며, 코드의 가독성과 구조적 유지보수를 향상시킵니다.
<br>

### 오늘의 도전 과제와 해결 방법
- json-server를 활용한 local server연결, fetch API 적용

### 오늘의 회고
-  생각 외로 API를 구현하는게 빡셌다
