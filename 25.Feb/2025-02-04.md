## 날짜 : 2025-02-04

### 스크럼
- 학습 목표 1 : 강의 과정에서 배운 스레드 개념 정리
- 학습 목표 2 : 모던 JavaScript 튜토리얼 읽으며 JS 내용 정리
- 학습 목표 3 : 과제 피드백 반영해 수정 (피드백 받을 시)
- 학습 목표 4 : 알고리즘 공부 (시간 있을 시)

### 새로 배운 내용
#### 주제 1: 프로세스
- CPU로부터 자원을 할당받아 실행 중인 프로그램
- 프로그램과의 차이 - Passive냐 active냐의 차이
    - 프로그램은 메모리에 load된 상태이지만 실행되어 유의미한 작업이 처리되지는 않는 상태임 (단순 code, instruction 뭉치라고 생각하면 됨)
    - 프로세스의 경우, 메모리에 load되고 CPU를 할당받아 유의미한 작업이 진행되고 있는 상태임

- 브라우저의 탭은 프로세스 or 스레드?
  - A`)` 프로세스
    - 브라우저 탭의 경우 스레드로 구성되었다면 한 탭에서 문제가 발생 시 브라우저 전체에 영향을 줄 수 있음 (심각한 경우 강제 종료)
    - 곰곰히 생각해보면 특정 브라우저 탭에서 문제 (freezing, 새로고침)가 다른 탭에 영향을 주지 않는다는 것을 알 수 있음. 
 
#### 주제 2: 스레드
- 한 프로세스 내에서 실행되는 특정 작업 흐름
- 스레드의 활용을 통해 여러 작업이 동시에 실행되는 느낌을 줄 수 있음 (Ex. - 워드프로세서에서 글 작성에 관여하는 스레드, 저장 작업에 관여하는 스레드…)
- 스레드는 프로세스의 code, data, heap 영역을 공유하고, stack의 경우 개별 스레드 스택을 가지게 됨 (스레드마다 return address, PC 등은 다를 것이기 때문에)
- 스레드의 스택은 프로세스의 스택 영역 중 일부를 스레드에 할당되어 생성됨
     
#### 주제 3: 컨텍스트 스위칭
- 작업이 진행되고 있는 프로세스/스레드의 정보를 저장하고, 다음에 시작되어야 할 프로세스/스레드의 정보를 가져와서 실행하는 것
- 프로세스의 경우 Process Control Block (PCB), 스레드의 경우 PCB에 포함되는 Thread Control Block (TCB)에 프로세스/스레드 실행에 필요한 내용들을 저장함. 
- 컨텍스트 스위칭이 발생하는 경우 현재 CPU를 점유하고 있는 프로세스/스레드의 상태, PC, 메모리 사용 등과 같은 정보를 개별 PCB에 저장하게 됨. 
    - 조금 더 low-level적 관점에서, 현재 실행되고 있는 OS의 커널이 이 PCB들을 관리하게 됨. 
- 새롭게 CPU에 할당되어야 하는 프로세스가 로드 되기 전, 현재까지 실행되고 있었던 프로세스의 PCB가 커널에 의해 어딘가에 저장된다. 그 후, 저장되어 있던, 실행되어야 할 프로세스의 PCB를 찾아 PC값을 보고, 실행되어야 하는 부분에서 실행을 재개. 

#### 주제 4: 스레드 오버헤드
- 스레드에서의 컨텍스트 스위칭, 생성, 삭제 등의 과정에서 발생하는 코스트
    - 프로세스에 비해 적은 자원을 소모하지만, 스레드 역시 컨텍스트 스위칭, 생성, 삭제 과정에서 자원 (시간, 메모리) 등을 사용하게 됨.
    - 그렇기 때문에 스레드를 무분별하게 많이 사용하는 경우 컨텍스트 스위치 등의 과정에서 소요되는 자원, 시간이 스레드의 수에 비례해서 늘어나게 됨. 

#### 주제 5: Synchonized
- 한 번에 한 스레드만 특정 블록에서 실행되도록 보장하는 자바의 예약어
  - Monitor or Lock을 이용해 동시성을 관리하는 방식
  - Lock을 이용해 임계 영역 (critical section) 진입 시, lock을 가지고 있는 스레드만이 진입해 실행되도록 하는 방식. 작업이 끝난 후에는 lock을 반환한다. 
  - 비슷한 개념으로는 뮤텍스(mutex), 세마포어 (semaphore)가 존재.
  - Lock과 mutex, semaphore의 차이점??
    - Lock - 프로세스 간 공유 X, 한 번에 하나의 스레드만 특정 자원에 접근 가능
    - Mutex - Lock의 기능과 동일. 하지만 mutex의 경우 프로세스 간 공유된다는 특징
    - Semaphore -  Mutex와 비슷하게 프로세스 간 공유됨. 차이점은 semaphore의 경우 한 개가 아닌 최대 여러 개까지의 스레드가 특정 자원에 접근하도록 허락. 

#### 주제 6: AtomicInteger
- 동시성을 보장받기 위한 변수 클래스
  - AtomicInteger 외에도 AtomicLong, AtomicBoolean, AtomicReference 등이 존재. 
  - Synchronized에 비해 적은 비용으로 동시성 관리가 가능하다는 특징
  - Compare-and-Swap (CAS)을 이용한 동시성 제어

#### 주제 6: 자바에서 지원하는 동시성 관리 방법
- 다음과 같은 방법들이 있음 
  - volatile 예약어
    - volatile = 휘발성이라는 의미. 변수를 Volatile로 선언하면 프로그램 실행 간 데이터의 변경사항을 캐시에 저장 후 메인 메모리에 반영하는 것이 아닌, 바로 메인 메모리에 변경을 가하겠다는 의미. 이 경우, 모든 스레드에서 같은 메모리 주소를 참조하여 변경이 발생 시 볼 수 있음.
    - volatile의 문제점은 경쟁 상태를 방지하지 않는다는 것. volatile 변수에 write 작업이 진행될 시, 작업의 mutual exclusion을 보장하지 않아 의도한 것과 다른 결과 값이 나올 수 있게 됨. 
  - Atomic 변수
  - Synchronized 
  - Executor 프레임워크
    - Executor 프레임워크는 매 번 객체를 새로 생성하는 것이 아닌, 기존에 생성되었던 스레드를 재활용하는 방식. 또한, 스레드 생성 후 CPU를 할당 받기 위해 경쟁하면서 대기하는 것이 아닌 Executor에서 관리하는 pool에서 대기하며 차례를 기다리기에 자원 관리에 있어 이점 존재.  

#### 주제 6: Thread Class를 상속 받는 것과 Runnable Interface를 사용하는 것의 차이
- Runnable은 인터페이스이기 때문에 그 자체로 스레드를 실행할 수는 없고, 추가적인 스레드 객체를 선언하고 실행을 해당 스레드에 위임해야 함.
- 스레드 클래스를 상속받아서 사용하게 되면 추가적인 작업 없이 직접적으로 스레드를 컨트롤할 수 있음
- 이렇게만 보면 스레드 클래스를 상속받아 사용하는 편이 코드가 깔끔하게 떨어지는 것이 보임. 그렇더라도 Runnable 인터페이스 + 추가적 스레드 선언을 통해 스레드 작업을 수행시키는 것이 일반적. 
  - 이렇게 하는 이유는 자바에서 다중 상속이 지원되지 않기 때문. 스레드 클래스를 상속 받는 경우, 미래에 상속이 필요한 경우에 대안이 없음. 
  - 또한, 스레드 클래스를 상속받아 스레드를 생성하면 각 스레드가 개별 객체를 관리함. 반면, Runnable 인터페이스를 통해 구현하는 경우 여러 스레드에서 동일한 객체를 공유한다는 차이가 존재. 이렇게 하는 경우 동시성 측면에서 작업 간 약한 결합도를 가질 수 있게 함

### 오늘의 도전 과제와 해결 방법
- 도전 과제 1: 자바에서의 스레드 사용법 익히기
  - 강의 교안을 보며 익숙해지는 시간을 가졌음

### 오늘의 회고
-  개념 정리 이후 추가적으로 JAVASCRIPT.INFO의 자료를 활용해 JS 공부를 진행했다. 이 과정에서 다소 특이한 연산자인 ',' (쉼표 연산자)나 비교 연산자 (>, <, >=, <=, ==, ===)의 경우 제대로 알고 있지 않다면 아리송할 수 있다는 것을 체감했다. 
