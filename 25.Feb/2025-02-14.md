## 날짜 : 2025-02-14

### 스크럼
1. 개념 정리
2. 앞서 정리한 내용들 잊지 않게 다시 보기
3. 과제 진행
4. 알고리즘 1문제라도
5. JS 책읽기, CSS 공부

### 새로 배운 내용
#### 주제 1: Stateful / Stateless
Stateful
- 상태 유지
- 서버가 클라이언트 상태를 보존
- Cookie, Session 등을 활용. 어딘가에 클라이언트의 정보를 저장하고 통신할 때마다 읽어서 사용함
- ex. 3-way handshaking
- 문제점
    - 서버에 문제가 생겨 새로운 서버를 사용해야 할 때
        - 로그인 했는데 새 서버에는 클라이언트 정보가 없음. → 재로그인 요청
        - 용량의 한계가 있어서 확장성 측면에서 아쉬움

Stateless
- 서버가 클라이언트의 상태를 보존하지 않음
- 서버는 단순이 요청이 오면 응답을 보내는 역할만 수행
- 클라이언트에서 정보를 가지고 있다가 서버와 통신할 때 같이 보냄
- JWT 토큰
- 문제점
    - 요청마다 부가정보를 줘야하므로 더 많은 데이터가 소모됨

확장성
- 수직 확장
    - 기존 서버 성능 향상
- 수평 확장
    - 서버 개수를 늘려 부하를 분산 → 상태 유지에 따라 수평 확장의 용이성이 다름
- Stateless는 서버가 세션을 저장하지 않고, 각 요청이 독립적 → 서버 개수를 편하게 늘려도 됨
- stateful은 서버를 늘릴 경우, 서버 간 세션 공유를 위한 기술이 필요

Stateless와 JWT
- 최대한 stateless를 지향해야 함. 하지만 특정 상황에서는 상태를 유지해야 할 필요가 있음
    → stateless의 특징을 유지하면서 로그인 상태를 유지하게 하는 기술이 JWT
    

사용자 상태나 세션 유지를 위해 사용하는 방법
1. 쿠키 기반
    1. Cookie - 클라이언트 쪽에 저장되는 세션과 관련된 정보를 담고 있는 작은 조각
    2. 요청 시, 메시지와 함께 쿠키를 첨부해서 서버에 전송
    3. `Set-Cookie`: 서버가 저장하려는 정보를 클라이언트에 쿠키로 저장하는데 사용하는 헤더
    4. 장단점
        1. 장점
            1. 간단하게 구현할 수 있다
        2. 단점
            1. XSS 공격으로 쿠키가 탈취될 수 있다 (`HttpOnly` 설정을 통해 보호)
            2. 로그인 상태 유지, 하루 동안 특정 팝업 창 다시 보지 않기 등에 사용
2. 서버 세션 기반
    1. 서버의 세션 저장소에 연결되었던 정보를 저장
    2. `Set-Cookie`를 이용해 세션의 아이디를 클라이언트에 알려줌
        1. 요청 시, 자동으로 쿠키 (세션 아이디)를 전송. 서버는 이를 바탕으로 세션 저장소에 저장된 정보를 가져와 조회 후 세션을 유지
3. JWT 기반
    1. 메모리 부담, 확장성 문제 등을 해결하기 위해 등장한 개념 
    2. 헤더, 페이로드, 서명으로 구성
    3. `쿠키`, `로컬 스토리지`에 보관, 요청 시 서버에 전송
    4. JWT 장점
        1. stateless, 따로 어딘가에 보관을 유지할 필요가 없음
        2. 서명을 통해 위변조 방지
        3. 토큰 자체에 인증 기능이 포함되어 있음
<br>

#### 주제 2: 브라우저 작동 방식
1. 탐색
    1. 브라우저 동작에 있어서 첫 번째 단계
    2. 유저가 URL을 요청함.
        1. url 입력
        2. 링크 클릭
    - 폼 제출
2. DNS 조회
    1. 페이지를 구성하는 정보가 어디에 있는지 찾는 단계
    2. 사람에게 친숙한 string 형태로 구성된 도메인 이름을 IP 주소로 변환하여 해당 주소에 조회를 요청
        1. DNS 캐시 상에 해당 정보가 있다면 캐시에 저장
        2. 처음 요청되는 도메인이라면 root DNS 서버를 통해 정보를 얻어와서 캐싱을 진행
3. 연결 요청
    1. TCP 3-way handshake
        1. SYN
            1. 클라이언트 → 서버, SYN 패킷을 통해 연결 요청을 알림. 이 때 초기 sequence #을 보냄.
        2. SYN-ACK
            1. 서버 → 클라이언트, ACK를 보냄  (클라이언트 seq # + 1). 서버 또한 SYN을 보냄 (서버 seq # + 1)
        
        iii.    ACK
        
        1. 클라이언트 → 서버, 서버 seq # + 1을 응답으로 보내 확인했다고 알림. 연결 성립
    2. TLS navigation (HTTPS 연결이라면)
        1. 보안을 위해서 진행되는 추가적 handshake
4. Response from Server
    1. 웹 서버와 연결 되었다면 브라우저에서 첫 HTTP GET request를 보냄
        1. 대부분은 HTML파일
    2. 서버가 요청을 받았다면 관련 있는 응답 header, HTML 내용을 response로 보냄
        1. 이 때, response는 패킷 단위로 전송되며, 첫 패킷은 일반적으로 14KB
5. 파싱
    1. 첫 패킷을 받은 후, 브라우저는 파싱을 시작함
    2. 파싱은 서버와 통신을 통해 받은 데이터를 바탕으로 DOM, CSSOM 구성하는 것
        1. HTML markup을 바탕으로 DOM tree 구성
            1. HTML의 **바이트 코드**를 가져와 지정된 인코딩 방법에 따라 **문자**로 변경한다
            2. Tokenization을 통해 start-end tag 단위로 잘라서 토큰을 바탕으로 DOM tree 구성을 진행
    2. reload Scanner
        1. DOM 트리를 만드는 프로세스는 메인 쓰레드를 차지
        2. 컨텐츠를 분석하고 CSS나 Javscript, 웹 폰트 같이 우선순위가 높은 자원을 요청
6. CSSOM 트리 구성
    - CSS의 내용을 바탕으로 CSSOM 트리를 구성. DOM과 비슷함
7. 렌더
    - DOM, CSSOM을 합쳐서 렌더 트리를 생성
    - 렌더 트리는 눈에 보이는 구성 요소들의 배치를 계산하기 위해 사용됨 (쉽게 말하면 화면 상에 출력 될 내용을 가공)
    1. 스타일
        - 렌더 트리를 바탕으로 DOM의 root node부터 하나씩 생성하기 시작.
        - 이 때, display: none과 같은 옵션이 주어진 상태라면 렌더 트리에는 추가되지 않음
        - Visibility: none 옵션이 추가된 node들은 렌더 트리에 추가됨
8. 레이아웃(배치)
    1. 렌더 트리를 기반으로 각 요소의 위치, 크기를 계산
        1. 요청하는 환경이 다 다를 수 있음 (PC, 스마트폰 등등)
        2. 이 때, 각 디바이스의 viewport 크기를 기준으로 맞게 크기, 위치를 계산해서 배치
    2. 페인팅
        - 현재까지의 과정에서 계산된 노드들의 크기, 배치, 스타일 요소 등을 기준으로 화면 상에 출력하기 시작.
9. 화면에 표시
<br>

#### 주제 3: HTTP 주요 메소드와 멱등성
- GET (멱등 O)
    - 서버의 리소스를 조회할 때 사용하는 method. 쿼리스트링을 통해 전달하고 싶은 데이터를 전달
    - 쿼리스트링 외에도 message body를 통해 데이터를 전달할 수 있지만 권장하지 않음
    - POST로도 데이터 조회는 가능하다만 GET은 캐싱이 가능해서 GET을 사용
- POST (멱등 X)
    - 전달한 데이터 처리/생성 요청 메소드
    - message body를 통해 서버로 데이터를 전달. 서버는 이 데이터를 처리해서 갱신을 진행
    - 신류 리소스 등록, 요청 처리에 사용
- PUT (멱등 O)
    - 리소스 수정 요청 시 사용하는 메소드
    - 데이터가 존재하면 덮어쓰고, 없는 경우 새로 생성한다.
    - 클라이언트가 구체적인 전체 경로를 지정해 보내줘야 함
- DELETE (멱등 O)
    - 리소스를 제거할 때 사용하는 메소드
    - 대부분 상태코드 200을 사용하나 상황에 따라 204를 사용할 수도 있음
- PATCH (멱등 X)
    - 리소스 일부 부분을 변경하는 메소드
    - PATCH를 지원하지 않는다면 대신 POST를 사용할 수 있음
<br>

#### 주제 4: Web Server와 Web Application Server의 차이
web server - 정적 컨텐츠를 HTTP를 통해 제공하는 서버

- 웹 페이지의 코드와 데이터를 호스팅
- HTTP 프로토콜을 사용해 통신
- 예시. `nginx`, `apache`

WAS - 동적 컨텐츠를 처리하고 제공하는 서버

Web Server와 WAS로 분리한 이유
1. 기능을 분리해 서버에 가해지는 부하를 덜기 위해
2. 물리적 분리를 통한 보안 강화

엄밀히 Web Server는 Web Application Server의 subset임
<br>

#### 주제 5: 정적 웹페이지와 동적 웹페이지의 차이
- 정적 웹 페이지 - 서버에 저장된 파일이 그대로 전달되는 웹 페이지
    - 서버의 데이터가 수정되지 않는 한 사용자는 동일한 웹 페이지를 보게 됨
    - 빠르고 비용이 적게 듦
    - 데이터가 모두 하드코딩 되어 있음

- 동적 웹 페이지 - url에 변화가 없는데 실시간으로 내용이 추가되거나 수정되는 웹 페이지. `(`ex. infinity scrolling이 적용된 웹`)`

- 사용자가 수행한 동작, 요청한 내용에 따라 다른 화면을 얻음
- 크게 `CSR` 방식과 `SSR` 방식으로 나뉨
    - CSR
        - 데이터가 없는 HTML 문서, static 파일을 먼저 얻어와 로드 후, 필요한 데이터를 요청하여 받아오는 방식
    - SSR
-SPA
    - 하나의 페이지 URL로 구성된 웹 애플리케이션
    - 필요한 정적 리소스를 한 번에 다운 받아서 사용. 새로운 페이지 요청 시에만 필요한 데이터를 받아옴 = CSR
    - 새로 고침 없이 컨텐츠 업데이트 가능

- MPA
    - 탭 이동 시마다 새 HTML을 받아와 페이지 전체를 렌더
    - 새로운 요청이 있을 때마다 서버에서 렌더링이 진행된 정적 리소스를 받아옴 = SSR

- SPA ↔ CSR / SSR ↔ MPA 을 엮어서 자주 사용함
<br>

#### 주제 6: JWT 탈취 방법
JWT 탈취 방법

`JWT`는 애플리케이션 간 정보 교환에 사용되는, JSON 형식의 자체 포함형 토큰

- Token은 사용자 인증, 데이터 전송, 설정 정보를 나타내는데 사용하는 정보 조각
- 자체포함형은 그것만으로 작동에 필요한 모든 정보가 담겨 있다는 의미
- JWT는 클라이언트에 저장. 요청마다 서버에 전달되며 서버에서 JWT의 유효성을 검사해 별다른 DB 조회 없이 사용자 인증 + 권한 확인이 가능
    
    ⇒ 인증과 인가를 위해 JWT 사용
    
    민감 정보를 요구할 때 사용하는 `식별 수단`
    

JWT를 이용한 인증 & 인가 과정

- 클라이언트가 요청을 보냄
- 서버에서 JWT를 만들어 클라이언트에 전송
- 클라이언트는 JWT를 저장하고, 매 요청 시마다 JWT를 포함에 요청 메시지 전달
- 서버에서 JWT의 유효성 검증, 검사 후 응답

탈취 가능 구간

- 서버 → 클라이언트 JWT 전송 과정
    - 네트워크 공격
        - MITM (Man-In-The-Middle): 중간자 공격, 네트워크에서 JWT를 가로챔
        - 패킷 스니핑: HTTP 요청을 감청
- 클라이언트 → 서버 요청 메시지 전달 과정
    - 네트워크 공격
        - XSS (크로스 사이트 스크맅팅): 웹 페이지에 악성 스크립트를 삽입해 브라우저의 로컬/세션 스토리지에 저장된 JWT를 탈취
        - CSRF(사이트 간 요청 위조): 서버인 척 요청을 보내도록 유도, 자동으로 JWT가 포함되어 전송

탈취 당했을 때의 문제

- 토큰을 이용해 인증/인가된 사용자인 척 할 수 있음
- 서버에서 관리하는 것이 아니기에 토큰을 즉시 만료 시킬 수 없음

해결할 수 있는 방법

- 탈취 예방: HttpOnly 쿠키
    - JWT를 쿠키에 저장하되 HttpOnly 속성을 적용해 클라이언트 스크립트가 토큰에 접근할 수 없도록
    - XSS로 인한 공격 방어
- JWT와 세션을 혼합해 사용
    - Access + Refresh 토큰 사용
        - access 토큰은 유효기간이 짧아서 탈취 당하더라도 피해를 줄일 수 있음
        - refresh 토큰은 유효기간을 길게 설정해 재발급의 목적으로 사용
- IP 주소 및 User-Agent 기반 토큰 관리
    - JWT 발급 시 추가적 보안 측정으로 발급된 IP주소, User-Agent 정보 저장
    - 이후 요청이 들어올 시, 동일한 정보를 가졌는지 판단 후 유효성 인정
    - 탈취 되더라도 다른 환경에서 사용되는 것을 막을 수 있다
탈취 확인하는 방법 : `의심스러운 활동을 감지`

- Access Token이 탈취되는 경우, Refresh Token이 탈취되는 경우가 있음
- 서버
    - JWT 사용 시 이상한 IP/User Agent 감지
    - Refresh Token 목록을 관리하고 사용 이력 추적
    - Access Token 유효 기간을 짧게 해 만료된 JWT 사용 감지
    - 새로운 로그인이 평소와 다른지 확인
    - 로그 데이터 분석
    - 사용자가 신고
- 클라이언트
    - JWt가 다른 네트워크에서 사용되는 경우 감지
    - 너무 짧은 간격으로 JWT가 여러 번 요청되는 경우 감지
    - 활성화된 세션을 주기적으로 확인
    - 로컬 스토리지/세션 스토리지의 변조 여부를 확인해 XSS 공격 차단

탈취 해결법: `Refresh Token 무효화`, `JWT 블랙리스트 저장`

- JWT 자체는 stateless라 서버에서 무효화하기 힘듦
- Refresh Token 또는 블랙리스트를 활용해 무효화를 해야 함
    - 의심스러운 활동 감지되면 Refresh Token, JWT를 모두 무효처리
        - Refresh Token 삭제
        - JWT 블랙리스트에 추가
    - 모든 세션을 강제로 만료시켜 JWT를 사용하지 못하도록
    - 사용자에게 보안 경고 발송 및 비밀번호 변경 요청
    - 2단계 인증 활성화 강제 적용
    - 탈취된 토큰이 사용된 후 새 로그인 발생 시, 추가 인증 요청
    - 보안 알림 경고

Refresh Token 저장소로 Redis를 사용하는 이유

- Redis는 키-값 쌍의 구조를 가진 NoSQL DBMS
- Access time이 빨라 Refresh Token 발급에 따른 병목현상 발생 X
- 데이터의 유효 기간 설정 가능
- Redis를 활용한 토큰 탈취 대응 시나리오
    - Refresh Token Rotation을 하더라도 해커가 Refresh Token을 사용자보다 먼저 사용한다면 …
        - 해커가 가진 Refresh Token 또한 Redis에 저장된다.
        - 만약 {Key: Value = Refresh Token: User} 형태로 저장한다면, 즉 Refresh Token이 key가 된다면, 한 user가 Refresh Token을 동시에 여러 개 가지는 문제가 발생한다.
        - 조치를 취하지 않으면 해커를 막을 수 없다 ..
    - 만약  {Key: Value = UserPK: Refresh Token} 방식으로 저장한다면
        - 해커와 사용자 둘 다 재발급을 요청했을 때 충돌 발생 → 탈취 감지할 수 있음
        - 그런 경우 Redis에서 토큰 정보 삭제하고 재로그인 요청
        - 하지만, 탈취 당했는데 사용자가 오랫동안 로그인하지 않는다면 막을 수 없다 😎
<br>

### 오늘의 도전 과제와 해결 방법
- 과제3 진행 과정에서 CSS와 관련해 어려움을 살짝 겪었다. flex-grid 시스템의 이해를 바탕으로 조금 더 figma에서 제공된 layout에 근접하게 구현하려는 노력을 진행했다. 

### 오늘의 회고
-  오늘은 CSS에 대한 개념 이해, 딥다이브 진행을 했다. 
