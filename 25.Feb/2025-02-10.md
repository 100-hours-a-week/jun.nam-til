## 날짜 : 2025-02-10

### 스크럼
1. 개념 정리
2. 앞서 정리한 내용들 잊지 않게 다시 보기
3. 과제 진행
4. 알고리즘 1문제라도
5. JS 책읽기, 스프링 기초 강의 보기

### 새로 배운 내용
#### 주제 1: 공유 자원
- 여러 프로세스, 사용자가 동시에 접근해서 사용하는 시스템 내 자원
  - 파일 시스템
  - 네트워크 프린터
  - **메모리**
    - 여러 프로세스가 동일 메모리 영역을 공유
  - 데이터베이스
<br>

- 왜 공유 자원을 사용하게 되나요?

  1. 자원 낭비 방지
    1. 개별적인 자원을 필요로 함 → 동일한 작업을 하더라도 일정 자원을 가져간다? 자원을 낭비하는 것과 같음
    2. 한정된 자원 —> 비슷한 일을 해야하는 친구들이 자원을 공유해서 쓴다면 효율성이 올라감
  2. 협업 가능성 증대

<br>

#### 주제 2: 임계 영역
- 공유 자원에 접근하는 프로그램 코드 부분
- 공유 자원이기에 여러 프로세스/스레드가 접근하면 문제가 생길 수 있는 구간을 의미
  - 여러 프로세스/스레드가 동일 변수/메모리 영역을 참조해 Write 작업을 하는 부분

- **해결 방법**

  - 동기화 메커니즘 (뮤텍스, 세마포어 등)의 사용을 통해 공유 자원에 접근하는 코드를 보호함. 즉, 해당 영역이 의도한 것과 다른 결과가 발생할 수 있는 부분이라면 한 번에 하나의 스레드/프로세스만 해당 영역에서 실행되도록 하는 것임
<br>

#### 주제 3: 동기화
- 여러 작업이 공유 자원에 동시에 접근할 때 생길 수 있는 데이터 일관성 문제 방지, 일관성 보장을 위한 기법
  1. 순서 보장
  2. 공유 자원 보호
  3. 경합 문제 해결

- 주의할 점: 동기화는 데이터 변경이 아닌 안전하게 읽고 쓰도록 하는 제어 방식에 관여하는 개념임

- 알아야 하는 이유
  1. 데이터 무결성 손실
      1. 동시에 공유 데이터가 수정을 가하는 경우, 의도하지 않은 결과값을 가지게 될 수 있음
  2. 데이터 경합
      1. 예측 불가능한 결과가 생길 수 있음
  3. 데드락
      1. 무한 대기 상태에 빠질 수 있음
<br>

#### 주제 4: 락 (Lock)
- 스레드나 프로세스가 자원을 점유한 경우, 다른 스레드/프로세스의 접근을 제한하도록 제어하는 기법
- **데이터 경합**, **데드락,** 그리고 원자성 보장과 같은 문제를 해결하기 위해 사용되는 동기화 매커니즘.
<br>

#### 주제 5: 원자성 (Atomicity)
- **작업 단위가 더 이상 나뉠 수 없는 하나의 "원자적" 실행 단위로 동작**함을 보장하는 개념
- 작업이 모두 실행되거나, 전부 실행되지 않거나를 의미.
- 예를 들어, a = 1+1 이라는 작업이 있을 때, 1+1의 연산, 해당 값의 변수 a로의 할당까지의 작업이 모두 진행되어서 a = 2의 값을 가지거나, a = 1+1이 수행되기 이전의 상태이거나 둘 중 하나여야 함. 
- 락을 사용하는 것으로 원자성을 지킬 수 있는데 이는 공유 변수를 사용하는 임계 영역에 대해 중단, 정보 간섭 없이 의도한 결과대로 완전하게 실행될 수 있음을 보장하기 때문
<br>

#### 주제 6: 상호배제, 진행, 유한한 대기
- 이 세 가지 개념은 critical section 문제를 해결하기 위해 충족해야 하는 조건

  1. 상호배제

    - 상호배제 (Mutual Exclusion)은 직역한 뜻과 같이 프로세스가 서로를 배척하도록 하는 개념이다. 정확하게는 임계 영역에서 실행 중인 프로세스가 있다면, 다른 프로세스가 임계 영역에 진입하도록 하는  것을 막는다는 것이다. 
    - 핵심: 하나의 프로세스만 임계 영역에 존재할 것

  2. 진행
    - 공유 자원을 사용하는 프로세스가 없고, 현재 대기 중인 프로세스가 있다면 대기 중인 프로세스 중 하나는 임계 영역에 진입해 실행되어야 함

  3. 유한한 대기
    - 특정 자원 요청 시, 언젠가는 할당 받아 실행될 수 있음을 보장받아야 함
<br>

#### 주제 7: 상호배제, 진행, 유한한 대기
- 이 세 가지 개념은 critical section 문제를 해결하기 위해 충족해야 하는 조건

  1. 상호배제

    - 상호배제 (Mutual Exclusion)은 직역한 뜻과 같이 프로세스가 서로를 배척하도록 하는 개념이다. 정확하게는 임계 영역에서 실행 중인 프로세스가 있다면, 다른 프로세스가 임계 영역에 진입하도록 하는  것을 막는다는 것이다. 
    - 핵심: 하나의 프로세스만 임계 영역에 존재할 것

  2. 진행
    - 공유 자원을 사용하는 프로세스가 없고, 현재 대기 중인 프로세스가 있다면 대기 중인 프로세스 중 하나는 임계 영역에 진입해 실행되어야 함

  3. 유한한 대기
    - 특정 자원 요청 시, 언젠가는 할당 받아 실행될 수 있음을 보장받아야 함
<br>

#### 주제 8: 상호배제, 진행, 유한한 대기
- thread 1에서 lock1, thread 2에서 lock2를 acquire하는데 서로 L2, L1을 기다리게 되면서 문제가 생김
- 스레드가 실행 중간에 context switching을 하지 않는다면 문제는 생기지 않음. 컨텍스트 스위칭을 하는 경우 발생하는 문제
- why deadlock occur?
    - Component 간 complex dependency가 존재하기 때문
        - Virtual memory system에서 paging을 위해 file system에 접근
        - File system은 virtual memory system이 disk에서 memory로 block을 읽기를 원하게 될 수 있음
    - Encapsulation을 성질 때문에
        - module화와 lock은 잘 조화되지 않음 = 모듈 내부의 encapsule된 정보들을 알 수 없어서
<br>

#### 주제 9: Race condition
- 두 개 이상의 프로세스가 공통 자원을 병행적으로(concurrently) 읽거나 쓰는 동작을 할 때,  데이터에 대한 실행 결과가 보장되지 않음을 의미.

- 프로세스가 자원에 접근한 순서에 따라 실행 결과에 차이가 발생할 수 있음. 

- Race condition이란 특정 자원에 대해 서로 사용하려고 경쟁하는 상황을 일컬음.

- 주로 Mutual Exclusion, Deadlock, Starvation과 같은 문제가 발생함 
<br>

#### 주제 10: 스핀 락, 낙관적 락 
- 스핀락의 경우 while() 문과 같은 반복문의 사용을 통해 특정 락의 상태를 계속해서 확인하는 방식으로 구현됨
  - Correctness: Yes 
    - 스핀락의 경우 락을 특정 스레드가 점유하고 있다면, 이후에 요청하는 스레드가 계속해서 락의 반환 여부를 busy-waiting 상태로 확인하고 있음. 
    - 이러한 상황에서 critical section에서 하나의 작업만 실행되는 것을 보장할 수 있음.
  - Fairness: No
    - While()에서 lock을 기다리는 thread가 여러 개 존재할 때, lock을 획득할 thread는 임의로 결정되므로 특정 thread가 starvation을 겪는 상태가 될 가능성이 존재함
- 낙관적 락
<br>

#### 주제 11: 뮤텍스
- MUTually EXclusive
- 상호 배제라는 단어에서 유래함. 

- 하나의 프로세스/스레드에서 mutex의 획득을 통해 공유 자원에 하나의 프로세스/스레드만 접근하는 것을 보장
<br>

#### 주제 11: 조건 변수(Condition Variable)
- MUTually EXclusive
- 상호 배제라는 단어에서 유래함. 

- 하나의 프로세스/스레드에서 mutex의 획득을 통해 공유 자원에 하나의 프로세스/스레드만 접근하는 것을 보장
<br>

#### 주제 12: Read-Write Lock
- 멀티 스레드 환경에서 Read 작업과 Write 작업을 구분해 Lock으로 관리하는 동기화 매커니즘

- 일반적으로 Read 작업은 수행 과정에서 공유 자원에 접근하더라도 단순 읽기만 하기 때문에 여러 작업을 동시에 허용해도 문제가 없다.

- 하지만, Write 작업의 경우 공유 자원에 대해 값의 변경을 진행하기 때문에 각 write 작업은 mutually exclusive하게 진행 될 필요가 있다. (공유 자원의 update에 대해 atomicity를 지키기 위해)

- 또한, Write 작업 시 read을 가능하도록 허용한다면 기대하는 것과 다른 값을 읽어올 수 있다. 반대로 read 작업 시 write 작업을 허용한다면 현재 읽어야 하는 정보에 변경점이 생기고 이로 인해 무결성이 깨지거나 심한 경우 프로그램에 심각한 문제를 일으킬 수도 있다.

- 따라서, Read-Write Lock에서는 read/write 작업 수행 전, write/read 작업에 대한 lock을 가져올 필요가 있다.
<br>

#### 주제 13: 세마포어
- 동기화 기법 중, 특정 자원에 대해 다중 접근을 허용하는 방식

- Mutual exclusion, bounded waiting을 바탕으로 구현되었음.
<br>

### 오늘의 도전 과제와 해결 방법
- 오늘은 딱히 새롭게 진행한 것이 없었다.

### 오늘의 회고
-  월요이리라 그런지 생각보다 월요병이 세게 온 느낌이었다. 집중도 잘 못했던 것 같은데 아직 찾아보지 못한 부분들은 다음에 추가적으로 찾아볼 것.
